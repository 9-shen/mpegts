<!DOCTYPE html>
<html>
<head>
	<title>MPEG-TS Parser demo</title>
	<script src="/jDataView/src/jdataview.js"></script>
	<script src="/jBinary/src/jbinary.js"></script>
	<script src="mpegts.js"></script>
	<script src="mp4.js"></script>
	<script src="pes.js"></script>
	<script src="h264.js"></script>
	<style type="text/css">
		.jsonContainer { color: #733; font-style: italic; word-wrap: break-word; display: block; float: left; width: 45%; margin-right: 2%; overflow-x: scroll; }
		.jsonValue { color: #373; font-weight: bold; font-style: normal; }
	</style>
</head>
<body>
	<video id="video" controls>
		<source id="source" type="video/mp4" />
	</video>
	<a id="url">Download</a>

	<script>
		if (true || !('time' in console)) {
			(function () {
				var timeStarts = {}, nowHost = typeof performance !== 'undefined' && 'now' in performance ? performance : Date;
				console.time = function (id) {
					timeStarts[id] = nowHost.now();
				};
				console.timeEnd = function (id) {
					console.log(document.title = id + ': ' + (nowHost.now() - timeStarts[id]) + ' ms');
					delete timeStarts[id];
				};
			})();
		}

		MPEGTS.loadFrom('data/sample.ts', function () {
			console.time('convert');

			console.time('read');
			var packets = this.read();
			console.timeEnd('read');

			console.time('getStream');
			var stream = new jDataView(this.binary.view.byteLength);
			for (var i = 0, length = packets.length; i < length; i++) {
				var packet = packets[i], adaptation = packet.adaptationField, payload = packet.payload;
				if (payload && payload._rawStream) {
					stream.writeBytes(payload._rawStream);
				}
			}
			console.timeEnd('getStream');

			console.time('filter');
			var original = stream.getBytes(stream.tell(), 0, true, true), pesStream = new jBinary(original, PES), audioStream = new jBinary(stream.byteLength), samples = [], curSample = {};
			stream.seek(0);
			for (var i = 0, start = 0, streamId, length = original.length; i <= length; i++) {
				if (i === length || (original[i] === 0 && original[i + 1] === 0 && original[i + 2] === 1)) {
					switch (streamId) {
						case 0x67:
							if (!sps) {
								var sps = original.slice(start, i);
								var spsInfo = new jBinary(sps, H264).read('SPS');
								var width = (spsInfo.pic_width_in_mbs_minus_1 + 1) * 16;
								var height = (2 - spsInfo.frame_mbs_only_flag) * (spsInfo.pic_height_in_map_units_minus_1 + 1) * 16;
								var cropping = spsInfo.frame_cropping;
								if (cropping) {
									width -= 2 * (cropping.left + cropping.right);
									height -= 2 * (cropping.top + cropping.bottom);
								}
							}
							break;

						case 0x68:
							if (!pps) {
								var pps = original.slice(start, i);
							}
							break;

						case 0x09:
							curSample.offset = stream.tell();
							samples.push(curSample);
							curSample = {};
							// copy all that were not parsed yet and do not have forbidden_zero_bit
							if (i > start && !(streamId & 0x80)) {
								stream.writeUint32(i - start);
								stream.writeBytes(original.slice(start, i));
							}
							break;

						case 0xC0:
							pesStream.seek(start + 1);
							var audioLength = pesStream.read('PESHeader').length;
							audioLength += -(pesStream.tell() - (start + 1)) + 2;
							audioStream.write('blob', pesStream.read(['blob', audioLength]));
							break;

						case 0xE0:
							try {
								pesStream.seek(start + 1);
								var pesHeader = pesStream.read('PESHeader');
								curSample.pts = pesHeader.pts;
								curSample.dts = pesHeader.dts || pesHeader.pts;
							} catch (e) { }
							break;

						case 0x65:
							curSample.isIDR = true;

						default:
							/*
							if (streamId === 0x01 || streamId === 0x41 || streamId === 0x65) {
								var sliceHeader = pesStream.view.slice(start + 1, i).toBinary(H264);
								sliceHeader.read('ExpGolomb');
								curSample.frameType = ['P', 'B', 'I', 'SP', 'SI'][sliceHeader.read('ExpGolomb') % 5];
							}
							*/
							// copy all that were not parsed yet and do not have forbidden_zero_bit
							if (i > start && !(streamId & 0x80)) {
								stream.writeUint32(i - start);
								stream.writeBytes(original.slice(start, i));
							}
							break;
					}
					start = i += 3;
					streamId = original[i];
				}
			}

			samples.push({offset: stream.tell()});

			var sizes = [], dtsDiffs = [], accessIndexes = [], pts_dts_Diffs = [], current = samples[0], frameRate = {sum: 0, count: 0}, duration = 0;
			for (var i = 0, length = samples.length - 1; i < length; i++) {
				var next = samples[i + 1];
				sizes.push(next.offset - current.offset);
				var dtsDiff = next.dts - current.dts;
				if (dtsDiff) {
					dtsDiffs.push({sample_count: 1, sample_delta: dtsDiff});
					duration += dtsDiff;
					frameRate.sum += dtsDiff;
					frameRate.count++;
				} else {
					dtsDiffs.length++;
				}
				if (current.isIDR) accessIndexes.push(i);
				pts_dts_Diffs.push({first_chunk: pts_dts_Diffs.length + 1, sample_count: 1, sample_offset: current.dtsFix = current.pts - current.dts});
				current = next;
			}
			frameRate = frameRate.sum / frameRate.count;
			for (var i = 0, length = dtsDiffs.length; i < length; i++) {
				if (dtsDiffs[i] === undefined) {
					dtsDiffs[i] = {first_chunk: i + 1, sample_count: 1, sample_delta: frameRate};
					duration += frameRate;
					//samples[i + 1].dts = samples[i].dts + frameRate;
				}
			}
			var dtsDiffsSame = true;
			for (var i = 1, length = dtsDiffs.length; i < length; i++) {
				if (dtsDiffs[i].sample_delta !== dtsDiffs[0].sample_delta) {
					dtsDiffsSame = false;
					break;
				}
			}
			if (dtsDiffsSame) {
				dtsDiffs = [{first_chunk: 1, sample_count: sizes.length, sample_delta: dtsDiffs[0].sample_delta}];
			}

			var audioStart = stream.tell(), audioSize = audioStream.tell(), audioSizes = [], isHeaderWritten = false, audioHeader;
			audioStream.seek(0);
			while (audioStream.tell() < audioSize) {
				audioHeader = audioStream.read({
					_start: function () { return this.binary.tell() },
					_syncWord: ['const', 12, 0xfff, true],
					version: ['enum', 1, ['mpeg-4', 'mpeg-2']],
					layer: ['const', 2, 0],
					isProtectionAbsent: 1,
					profile: 2, // http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Object_Types minus one
					samplingFreqIndex: 4, // http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Sampling_Frequencies
					_privateStream: 1,
					channelConfig: 3, // http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Channel_Configurations
					_reserved: 4, // originality, home, copyrighted, copyright start bits
					frameLength: 13,
					bufferFullness: 11,
					aacFramesCountMinusOne: 2,
					data: ['blob', function (context) { return context.frameLength - (this.binary.tell() - context._start) }]
				});
				audioSizes.push(isHeaderWritten ? audioHeader.data.length : audioHeader.frameLength);
				stream.writeBytes(isHeaderWritten ? audioHeader.data : audioStream.read(['blob', audioHeader.frameLength], audioHeader._start));
				isHeaderWritten = true;
			}

			console.timeEnd('filter');

			// return console.log(audioStream.slice(0, audioStream.tell()).toBinary().toURL(), samples.slice(0, -1), sizes, dtsDiffs, accessIndexes, pts_dts_Diffs);

			console.time('build');
			var file = new MP4(stream.byteLength);
			file.write({
				ftyp: [{
					major_brand: 'isom',
					minor_version: 512,
					compatible_brands: ['isom', 'iso2', 'avc1', 'mp41']
				}],
				mdat: [{
					_rawData: stream.getBytes(stream.tell(), 0)
				}],
				moov: [{
					atoms: {
						mvhd: [{
							version: 0,
							flags: 0,
							timescale: 90000,
							duration: duration,
							rate: 1,
							volume: 1,
							matrix: {
								a: 1, b: 0, x: 0,
								c: 0, d: 1, y: 0,
								u: 0, v: 0, w: 1
							},
							next_track_ID: 2
						}],
						trak: [
							{
								atoms: {
									tkhd: [{
										version: 0,
										flags: 15,
										track_ID: 1,
										duration: duration,
										layer: 0,
										alternate_group: 0,
										volume: 1,
										matrix: {
											a: 1, b: 0, x: 0,
											c: 0, d: 1, y: 0,
											u: 0, v: 0, w: 1
										},
										dimensions: {
											horz: width,
											vert: height
										}
									}],
									edts: [{
										atoms: {
											elst: [{
												version: 0,
												flags: 0,
												entries: [{
													segment_duration: duration,
													media_time: 0,
													media_rate: 1
												}]
											}]
										}
									}],
									mdia: [{
										atoms: {
											mdhd: [{
												version: 0,
												flags: 0,
												timescale: 90000,
												duration: duration,
												lang: 'und'
											}],
											hdlr: [{
												version: 0,
												flags: 0,
												handler_type: 'vide',
												name: 'VideoHandler'
											}],
											minf: [{
												atoms: {
													vmhd: [{
														version: 0,
														flags: 1,
														graphicsmode: 0,
														opcolor: {r: 0, g: 0, b: 0}
													}],
													dinf: [{
														atoms: {
															dref: [{
																version: 0,
																flags: 0,
																entries: [{
																	type: 'url ',
																	version: 0,
																	flags: 1,
																	location: ''
																}]
															}]
														}
													}],
													stbl: [{
														atoms: {
															stsd: [{
																version: 0,
																flags: 0,
																entries: [{
																	type: 'avc1',
																	data_reference_index: 1,
																	dimensions: {
																		horz: width,
																		vert: height
																	},
																	resolution: {
																		horz: 72,
																		vert: 72
																	},
																	frame_count: 1,
																	compressorname: '',
																	depth: 24,
																	atoms: {
																		avcC: [{
																			version: 1,
																			profileIndication: spsInfo.profile_idc,
																			profileCompatibility: parseInt(spsInfo.constraint_set_flags.join(''), 2),
																			levelIndication: spsInfo.level_idc,
																			lengthSizeMinusOne: 3,
																			seqParamSets: [sps],
																			pictParamSets: [pps]
																		}]
																	}
																}]
															}],
															stts: [{
																version: 0,
																flags: 0,
																entries: dtsDiffs
															}],
															stss: [{
																version: 0,
																flags: 0,
																entries: accessIndexes
															}],
															ctts: [{
																version: 0,
																flags: 0,
																entries: pts_dts_Diffs
															}],
															stsc: [{
																version: 0,
																flags: 0,
																entries: [{
																	first_chunk: 1,
																	samples_per_chunk: sizes.length,
																	sample_description_index: 1
																}]
															}],
															stsz: [{
																version: 0,
																flags: 0,
																sample_size: 0,
																sample_count: sizes.length,
																sample_sizes: sizes
															}],
															stco: [{
																version: 0,
																flags: 0,
																entries: [0x28]
															}]
														}
													}]
												}
											}]
										}
									}]
								}
							},
							{
								atoms: {
									tkhd: [{
										version: 0,
										flags: 15,
										track_ID: 2,
										duration: duration,
										layer: 0,
										alternate_group: 1,
										volume: 1,
										matrix: {
											a: 1, b: 0, x: 0,
											c: 0, d: 1, y: 0,
											u: 0, v: 0, w: 1
										},
										dimensions: {
											horz: 0,
											vert: 0
										}
									}],
									edts: [{
										atoms: {
											elst: [{
												version: 0,
												flags: 0,
												entries: [{
													segment_duration: duration,
													media_time: 0,
													media_rate: 1
												}]
											}]
										}
									}],
									mdia: [{
										atoms: {
											mdhd: [{
												version: 0,
												flags: 0,
												timescale: 22050,
												duration: duration / 90000 * 22050,
												lang: 'eng'
											}],
											hdlr: [{
												version: 0,
												flags: 0,
												handler_type: 'soun',
												name: 'SoundHandler'
											}],
											minf: [{
												atoms: {
													smhd: [{
														version: 0,
														flags: 0,
														balance: 0
													}],
													dinf: [{
														atoms: {
															dref: [{
																version: 0,
																flags: 0,
																entries: [{
																	type: 'url ',
																	version: 0,
																	flags: 1,
																	location: ''
																}]
															}]
														}
													}],
													stbl: [{
														atoms: {
															stsd: [{
																version: 0,
																flags: 0,
																entries: [{
																	type: 'mp4a',
																	data_reference_index: 1,
																	channelcount: 2,
																	samplesize: 16,
																	samplerate: 22050,
																	atoms: {
																		esds: [{
																			version: 0,
																			flags: 0,
																			sections: [
																				{
																					descriptor_type: 3,
																					ext_type: 128,
																					length: 34,
																					es_id: 2,
																					stream_priority: 0
																				},
																				{
																					descriptor_type: 4,
																					ext_type: 128,
																					length: 20,
																					type: 64,
																					stream_type: 5,
																					upstream_flag: 0,
																					buffer_size: 0,
																					maxBitrate: 31402,
																					avgBitrate: 31395
																				},
																				{
																					descriptor_type: 5,
																					ext_type: 128,
																					length: 2,
																					audio_profile: 2,
																					sampling_freq: 44100,
																					channelConfig: 2,
																					frameLength: 1024
																				},
																				{
																					descriptor_type: 6,
																					ext_type: 128,
																					length: 1,
																					sl: 2
																				}
																			]
																		}]
																	}
																}]
															}],
															stts: [{
																version: 0,
																flags: 0,
																entries: [{
																	sample_count: audioSizes.length,
																	sample_delta: 2048
																}]
															}],
															stsc: [{
																version: 0,
																flags: 0,
																entries: [{
																	first_chunk: 1,
																	samples_per_chunk: audioSizes.length,
																	sample_description_index: 1
																}]
															}],
															stsz: [{
																version: 0,
																flags: 0,
																sample_size: 0,
																sample_count: audioSizes.length,
																sample_sizes: audioSizes
															}],
															stco: [{
																version: 0,
																flags: 0,
																entries: [0x28 + audioStart]
															}]
														}
													}]
												}
											}]
										}
									}]
								}
							}
						]
					}
				}]
			});
			console.timeEnd('build');

			console.time('generateURL');
			var url = new MP4(file.binary.view.slice(0, file.binary.tell())).toURL();
			console.timeEnd('generateURL');

			console.timeEnd('convert');

			document.getElementById('video').src = url;
			document.getElementById('source').src = url;
			document.getElementById('url').href = url;
		});
	</script>
</body>
</html>
